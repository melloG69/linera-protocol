<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="What `#[derive(Add)]` generates"><title>BitXor in derive_more::derive - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="derive_more" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../derive_more/index.html">derive_more</a><span class="version">1.0.0</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In derive_more::derive</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Derive Macro <a href="../index.html">derive_more</a>::<wbr><a href="index.html">derive</a>::<wbr><a class="derive" href="#">BitXor</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/derive_more_impl/lib.rs.html#103">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[derive(BitXor)]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="what-deriveadd-generates"><a class="doc-anchor" href="#what-deriveadd-generates">§</a>What <code>#[derive(Add)]</code> generates</h2>
<p>The derived <code>Add</code> implementation will allow two structs of the same type to be
added together. This is done by adding their respective fields together and
creating a new struct with those values.
For enums each variant can be added in a similar way to another instance of that
same variant. There’s one big difference however: it returns a
<code>Result&lt;EnumType&gt;</code>, because an error is returned when two different variants are
added together.</p>
<h3 id="tuple-structs"><a class="doc-anchor" href="#tuple-structs">§</a>Tuple structs</h3>
<p>When deriving <code>Add</code> for a tuple struct with two fields like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Add)]
</span><span class="kw">struct </span>MyInts(i32, i32);</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::Add <span class="kw">for </span>MyInts {
    <span class="kw">type </span>Output = MyInts;
    <span class="kw">fn </span>add(<span class="self">self</span>, rhs: MyInts) -&gt; MyInts {
        MyInts(<span class="self">self</span>.<span class="number">0</span>.add(rhs.<span class="number">0</span>), <span class="self">self</span>.<span class="number">1</span>.add(rhs.<span class="number">1</span>))
    }
}</code></pre></div>
<p>The behaviour is similar with more or less fields.</p>
<h3 id="regular-structs"><a class="doc-anchor" href="#regular-structs">§</a>Regular structs</h3>
<p>When deriving <code>Add</code> for a regular struct with two fields like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Add)]
</span><span class="kw">struct </span>Point2D {
    x: i32,
    y: i32,
}</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::Add <span class="kw">for </span>Point2D {
    <span class="kw">type </span>Output = Point2D;
    <span class="kw">fn </span>add(<span class="self">self</span>, rhs: Point2D) -&gt; Point2D {
        Point2D {
            x: <span class="self">self</span>.x.add(rhs.x),
            y: <span class="self">self</span>.y.add(rhs.y),
        }
    }
}</code></pre></div>
<p>The behaviour is similar for more or less fields.</p>
<h3 id="enums"><a class="doc-anchor" href="#enums">§</a>Enums</h3>
<p>There’s a big difference between the code that is generated for the two struct
types and the one that is generated for enums. The code for enums returns
<code>Result&lt;EnumType&gt;</code> instead of an <code>EnumType</code> itself. This is because adding an
enum to another enum is only possible if both are the same variant. This makes
the generated code much more complex as well, because this check needs to be
done. For instance when deriving <code>Add</code> for an enum like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Add)]
</span><span class="kw">enum </span>MixedInts {
    SmallInt(i32),
    BigInt(i64),
    TwoSmallInts(i32, i32),
    NamedSmallInts { x: i32, y: i32 },
    UnsignedOne(u32),
    UnsignedTwo(u32),
    Unit,
}</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::Add <span class="kw">for </span>MixedInts {
    <span class="kw">type </span>Output = <span class="prelude-ty">Result</span>&lt;MixedInts, derive_more::BinaryError&gt;;
    <span class="kw">fn </span>add(<span class="self">self</span>, rhs: MixedInts) -&gt; <span class="prelude-ty">Result</span>&lt;MixedInts, derive_more::BinaryError&gt; {
        <span class="kw">match </span>(<span class="self">self</span>, rhs) {
            (MixedInts::SmallInt(__l_0), MixedInts::SmallInt(__r_0)) =&gt; {
                <span class="prelude-val">Ok</span>(MixedInts::SmallInt(__l_0.add(__r_0)))
            }
            (MixedInts::BigInt(__l_0), MixedInts::BigInt(__r_0)) =&gt; {
                <span class="prelude-val">Ok</span>(MixedInts::BigInt(__l_0.add(__r_0)))
            }
            (MixedInts::TwoSmallInts(__l_0, __l_1), MixedInts::TwoSmallInts(__r_0, __r_1)) =&gt; {
                <span class="prelude-val">Ok</span>(MixedInts::TwoSmallInts(__l_0.add(__r_0), __l_1.add(__r_1)))
            }
            (MixedInts::NamedSmallInts { x: __l_0, y: __l_1 },
             MixedInts::NamedSmallInts { x: __r_0, y: __r_1 }) =&gt; {
                <span class="prelude-val">Ok</span>(MixedInts::NamedSmallInts {
                    x: __l_0.add(__r_0),
                    y: __l_1.add(__r_1),
                })
            }
            (MixedInts::UnsignedOne(__l_0), MixedInts::UnsignedOne(__r_0)) =&gt; {
                <span class="prelude-val">Ok</span>(MixedInts::UnsignedOne(__l_0.add(__r_0)))
            }
            (MixedInts::UnsignedTwo(__l_0), MixedInts::UnsignedTwo(__r_0)) =&gt; {
                <span class="prelude-val">Ok</span>(MixedInts::UnsignedTwo(__l_0.add(__r_0)))
            }
            (MixedInts::Unit, MixedInts::Unit) =&gt; <span class="prelude-val">Err</span>(derive_more::BinaryError::Unit(
                derive_more::UnitError::new(<span class="string">"add"</span>),
            )),
            <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(derive_more::BinaryError::Mismatch(
                derive_more::WrongVariantError::new(<span class="string">"add"</span>),
            )),
        }
    }
}</code></pre></div>
<p>Also note the Unit type that throws an error when adding it to itself.</p>
</div></details></section></div></main></body></html>